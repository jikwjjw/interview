[常见性能优化策略的总结](https://tech.meituan.com/2016/12/02/performance-tunning.html)
+ 代码优化
  + for循环次数过多，作了很多无用的条件判断，相同逻辑重复多次
----------------------------------------
+ 数据库
  + SQL调优
    + 通过explain等工具调优，查看是否使用索引等。
  + 架构层面调优
    + 这一类调优包括读写分离，多从库负载均衡，水平和垂直分库分表等方面。通过内部监控报警系统，定期跟踪一些指标数据是否达到瓶颈，一旦达到瓶颈或警戒值，就需要考虑架构层面的调优
  + 连接池调优
    + 结合当前使用的连接池原理，具体的连接池参数，和当前的业务量做一个综合判断，达到最终的调优结果。
----------------------------------------
+ 缓存
  + 缓存场景：
    + 短时间内相同数据重复查询多次且数据更新不频繁，这个时候可以选择先从缓存查询，查询不到再从数据库加载并回设到缓存的方式。此种场景较适合用单机缓存。
    + 高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛。
  + 选型考虑：
    + 如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以选择本地缓存。具体的话，如果需要一些策略的支持（比如缓存满的逐出策略），可以考虑Ehcache；如不需要，可以考虑HashMap；如需要考虑多线程并发的场景，可以考虑ConcurentHashMap。
    + 其他情况，可以考虑缓存服务。目前从资源的投入度、可运维性、是否能动态扩容以及配套设施来考虑，我们优先考虑Tair。除非目前Tair还不能支持的场合（比如分布式锁、Hash类型的value），我们考虑用Redis。
  + 缓存满了怎么办：
    + 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU
    + 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。
    + 给一些没有必要长期保存的key，尽量设置过期时间。
  + 缓存击穿问题：
    + 概念：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
    + 解决：业界比较常用的做法，是使用mutex(分布式互斥锁，保证数据一致性)。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：
    ```
    public String get(key) {
    String value = redis.get(key);
    if (value == null) { //代表缓存值过期
        //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置锁成功
            value = db.get(key);                       //从DB中取值
            redis.set(key, value, expire_secs);        //给热点数据设置新的过期时间
            redis.del(key_mutex);                      //删除锁
            } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                    sleep(50);
                    get(key);  //重试
            }
        } else {
            return value;      
        }
    }
    ```
    + Redis 锁主要利用 Redis 的 setnx 命令。
      + 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
      + 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
      + 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。
----------------------------------------
